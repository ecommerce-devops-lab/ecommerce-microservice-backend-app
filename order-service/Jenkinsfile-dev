pipeline {
    agent any
    
    parameters {
        string(name: 'BRANCH_NAME', defaultValue: 'develop', description: 'Branch to build')
        string(name: 'COMMIT_SHA', defaultValue: 'HEAD', description: 'Commit SHA')
        booleanParam(name: 'SKIP_SONAR', defaultValue: true, description: 'Skip SonarQube analysis')
        booleanParam(name: 'SKIP_SECURITY_SCAN', defaultValue: false, description: 'Skip Trivy security scan')
        booleanParam(name: 'SKIP_DEPLOY', defaultValue: true, description: 'Skip deployment (no k8s configured)')
        booleanParam(name: 'SKIP_GCP_PUSH', defaultValue: false, description: 'Skip GCP Registry push')
    }
    
    environment {
        // GCP Configuration
        GCP_PROJECT_ID = 'ecommerce-microservices-back'
        GCP_REGISTRY = "gcr.io/ecommerce-microservices-back"
        
        // Versioning
        IMAGE_TAG = "${params.COMMIT_SHA.take(7)}-${BUILD_NUMBER}"
        
        // Credentials (conditional)
        GOOGLE_APPLICATION_CREDENTIALS = credentials('gcp-service-account-key')
        SONAR_TOKEN = credentials('sonarqube-token')
        // GITHUB_TOKEN = credentials('github-token')  // Commented out until created
        
        // Local tool paths
        GCLOUD_PATH = "${env.WORKSPACE}/.tools/google-cloud-sdk/bin"
        DOCKER_PATH = "${env.WORKSPACE}/.tools/bin"
        KUBECTL_PATH = "${env.WORKSPACE}/.tools/bin"
        PATH = "${env.DOCKER_PATH}:${env.GCLOUD_PATH}:${env.KUBECTL_PATH}:/usr/local/bin:/usr/bin:/bin"
    }
    
    tools {
        maven 'Maven-3.9.4'
        jdk 'OpenJDK-17'
    }
    
    stages {
        stage('Setup Tools') {
            steps {
                script {
                    sh '''
                        echo "Setting up tools in user space..."
                        
                        # Create tools directory
                        mkdir -p ${WORKSPACE}/.tools/bin
                        cd ${WORKSPACE}/.tools
                        
                        # Install Docker CLI (static binary, no root needed)
                        if [ ! -f "bin/docker" ]; then
                            echo "Installing Docker CLI..."
                            curl -fsSL https://download.docker.com/linux/static/stable/x86_64/docker-24.0.7.tgz | tar xzf - --strip 1 -C bin docker/docker
                            chmod +x bin/docker
                        fi
                        
                        # Configure Docker socket permissions
                        echo "Configurando permisos de Docker..."
                        if [ -S /var/run/docker.sock ]; then
                            # Obtener el grupo del socket Docker
                            DOCKER_GROUP=$(stat -c %g /var/run/docker.sock)
                            echo "Grupo del socket Docker: $DOCKER_GROUP"
                            
                            # Agregar el usuario jenkins al grupo
                            if ! groups jenkins | grep -q $DOCKER_GROUP; then
                                echo "Agregando usuario jenkins al grupo $DOCKER_GROUP"
                                groupadd -g $DOCKER_GROUP docker || true
                                usermod -aG $DOCKER_GROUP jenkins || true
                            fi
                            
                            # Verificar permisos
                            ls -l /var/run/docker.sock
                            groups jenkins
                        fi
                        
                        # Install Google Cloud SDK
                        if [ ! -d "google-cloud-sdk" ]; then
                            echo "Installing Google Cloud SDK..."
                            curl https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-456.0.0-linux-x86_64.tar.gz | tar -xzf -
                            ./google-cloud-sdk/install.sh --quiet --path-update=false --bash-completion=false --usage-reporting=false
                        fi
                        
                        # Install kubectl
                        if [ ! -f "bin/kubectl" ]; then
                            echo "Installing kubectl..."
                            curl -LO "https://dl.k8s.io/release/v1.28.0/bin/linux/amd64/kubectl"
                            chmod +x kubectl
                            mv kubectl bin/
                        fi
                        
                        # Install jq
                        if [ ! -f "bin/jq" ]; then
                            echo "Installing jq..."
                            curl -L https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64 -o bin/jq
                            chmod +x bin/jq
                        fi
                        
                        # Install Trivy
                        if [ ! -f "bin/trivy" ]; then
                            echo "Installing Trivy..."
                            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b bin v0.48.3
                        fi
                        
                        echo "Tools setup completed"
                        echo "Verifying installations:"
                        ${WORKSPACE}/.tools/bin/docker --version || echo "Docker: FAILED"
                        ${WORKSPACE}/.tools/google-cloud-sdk/bin/gcloud --version | head -1 || echo "gcloud: FAILED"
                        ${WORKSPACE}/.tools/bin/kubectl version --client || echo "kubectl: FAILED"
                        ${WORKSPACE}/.tools/bin/jq --version || echo "jq: FAILED"
                        ${WORKSPACE}/.tools/bin/trivy --version || echo "trivy: FAILED"
                    '''
                }
            }
        }
        
        stage('Initialize') {
            steps {
                script {
                    // Set dynamic environment variables
                    env.SERVICE_NAME = env.JOB_NAME.split('-dev')[0]
                    env.SERVICE_PORT = getServicePort(env.SERVICE_NAME)
                    env.BUILT_IMAGE = "${env.GCP_REGISTRY}/${env.SERVICE_NAME}:${env.IMAGE_TAG}"
                    env.BUILT_LATEST_IMAGE = "${env.GCP_REGISTRY}/${env.SERVICE_NAME}:dev-latest"
                    
                    currentBuild.description = "Building ${env.SERVICE_NAME}:${env.IMAGE_TAG}"
                    
                    echo "=== Pipeline Configuration ==="
                    echo "Service: ${env.SERVICE_NAME}"
                    echo "Port: ${env.SERVICE_PORT}"
                    echo "Image Tag: ${env.IMAGE_TAG}"
                    echo "Branch: ${params.BRANCH_NAME}"
                    echo "GCP Registry: ${env.GCP_REGISTRY}"
                    echo "Built Image: ${env.BUILT_IMAGE}"
                    
                    // Initialize GCP (conditional)
                    if (!params.SKIP_GCP_PUSH) {
                        sh '''
                            export PATH=${DOCKER_PATH}:${GCLOUD_PATH}:${KUBECTL_PATH}:$PATH
                            export GOOGLE_APPLICATION_CREDENTIALS=$GOOGLE_APPLICATION_CREDENTIALS
                            
                            echo "Authenticating with GCP..."
                            gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS || echo "GCP auth failed - continuing without GCP"
                            gcloud config set project $GCP_PROJECT_ID || echo "Project set failed - continuing"
                            gcloud auth configure-docker gcr.io --quiet || echo "Docker auth failed - continuing"
                            
                            echo "GCP authentication attempted"
                        '''
                    } else {
                        echo "Skipping GCP authentication (SKIP_GCP_PUSH=true)"
                    }
                }
            }
        }
        
        stage('Checkout & Change Detection') {
            steps {
                // Simple checkout without credentials for public repo
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "${params.BRANCH_NAME}"]],
                    userRemoteConfigs: [[
                        url: 'https://github.com/ecommerce-devops-lab/ecommerce-microservice-backend-app.git'
                    ]]
                ])
                
                script {
                    // Detect changes for this specific service
                    def hasChanges = sh(
                        script: """
                            if [ "${params.BRANCH_NAME}" = "develop" ] && [ "${params.COMMIT_SHA}" != "HEAD" ]; then
                                git diff --name-only ${params.COMMIT_SHA}~1 ${params.COMMIT_SHA} | grep -q "^${env.SERVICE_NAME}/" || echo "no-changes"
                            else
                                echo "force-build"
                            fi
                        """,
                        returnStdout: true
                    ).trim()
                    
                    if (hasChanges == 'no-changes') {
                        currentBuild.result = 'NOT_BUILT'
                        currentBuild.description = "No changes detected for ${env.SERVICE_NAME}"
                        echo "No changes detected for ${env.SERVICE_NAME}, but continuing build as requested"
                    }
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                dir("${env.SERVICE_NAME}") {
                    script {
                        // Configuración mejorada de Java
                        sh '''
                            echo "Configurando entorno Java..."
                            
                            # Crear directorio para Java si no existe
                            mkdir -p ${WORKSPACE}/.tools/java
                            
                            # Descargar e instalar OpenJDK si no está instalado
                            if [ ! -d "${WORKSPACE}/.tools/java/openjdk-17" ]; then
                                echo "Instalando OpenJDK 17..."
                                cd ${WORKSPACE}/.tools
                                curl -L https://download.java.net/java/GA/jdk17/0d483333a00540d886896bac774ff48b/35/GPL/openjdk-17_linux-x64_bin.tar.gz -o openjdk.tar.gz
                                tar xzf openjdk.tar.gz
                                mv jdk-17* java/openjdk-17
                                rm openjdk.tar.gz
                            fi
                            
                            # Configurar Java
                            export JAVA_HOME="${WORKSPACE}/.tools/java/openjdk-17"
                            export PATH="$JAVA_HOME/bin:$PATH"
                            
                            # Verificar la instalación
                            echo "JAVA_HOME: $JAVA_HOME"
                            echo "Java version:"
                            $JAVA_HOME/bin/java -version
                            
                            echo "Ejecutando pruebas unitarias para ${SERVICE_NAME}..."
                            mvn clean test \
                                -Dmaven.test.failure.ignore=false \
                                -Dspring.profiles.active=test \
                                -DforkCount=1 \
                                -DreuseForks=false \
                                -Dmaven.compiler.source=17 \
                                -Dmaven.compiler.target=17
                        '''
                    }
                }
            }
            post {
                always {
                    script {
                        try {
                            // Use junit instead of publishTestResults
                            junit testResultsPattern: "${env.SERVICE_NAME}/target/surefire-reports/*.xml", allowEmptyResults: true
                            echo "Test results published successfully"
                        } catch (Exception e) {
                            echo "Test results not found or could not be published: ${e.getMessage()}"
                        }
                        
                        try {
                            // Archive test reports
                            archiveArtifacts(
                                artifacts: "${env.SERVICE_NAME}/target/surefire-reports/**",
                                allowEmptyArchive: true
                            )
                        } catch (Exception e) {
                            echo "Could not archive test artifacts: ${e.getMessage()}"
                        }
                    }
                }
            }
        }
        
        stage('SonarQube Analysis') {
            when {
                expression { !params.SKIP_SONAR }
            }
            steps {
                dir("${env.SERVICE_NAME}") {
                    withSonarQubeEnv('sonarqube-server') {

                        sh '''
                        echo "Configurando entorno Java..."
                            
                            # Crear directorio para Java si no existe
                            mkdir -p ${WORKSPACE}/.tools/java
                            
                            # Descargar e instalar OpenJDK si no está instalado
                            if [ ! -d "${WORKSPACE}/.tools/java/openjdk-17" ]; then
                                echo "Instalando OpenJDK 17..."
                                cd ${WORKSPACE}/.tools
                                curl -L https://download.java.net/java/GA/jdk17/0d483333a00540d886896bac774ff48b/35/GPL/openjdk-17_linux-x64_bin.tar.gz -o openjdk.tar.gz
                                tar xzf openjdk.tar.gz
                                mv jdk-17* java/openjdk-17
                                rm openjdk.tar.gz
                            fi
                            
                            # Configurar Java
                            export JAVA_HOME="${WORKSPACE}/.tools/java/openjdk-17"
                            export PATH="$JAVA_HOME/bin:$PATH"
                            
                            # Verificar la instalación
                            echo "JAVA_HOME: $JAVA_HOME"
                            echo "Java version:"
                            $JAVA_HOME/bin/java -version
                            
                            echo "Running SonarQube analysis for Community Edition..."
                            echo "Current directory: $(pwd)"
                            echo "Service: ${SERVICE_NAME}"
                            echo "Branch: ${BRANCH_NAME}"
                            
                            # Diferentes configuraciones según el branch
                            if [ "${BRANCH_NAME}" = "main" ] || [ "${BRANCH_NAME}" = "master" ]; then
                                PROJECT_KEY="ecommerce-${SERVICE_NAME}"
                                PROJECT_NAME="E-commerce ${SERVICE_NAME}"
                            else
                                # Para branches de desarrollo, usar suffix
                                PROJECT_KEY="ecommerce-${SERVICE_NAME}-${BRANCH_NAME}"
                                PROJECT_NAME="E-commerce ${SERVICE_NAME} (${BRANCH_NAME})"
                            fi
                            
                            echo "Project Key: $PROJECT_KEY"
                            echo "Project Name: $PROJECT_NAME"
                            
                            # Ejecutar análisis SonarQube (Community Edition compatible)
                            mvn org.sonarsource.scanner.maven:sonar-maven-plugin:4.0.0.4121:sonar \
                                -Dsonar.projectKey=$PROJECT_KEY \
                                -Dsonar.projectName="$PROJECT_NAME" \
                                -Dsonar.projectVersion=${IMAGE_TAG} \
                                -Dsonar.java.source=17 \
                                -Dsonar.java.target=17 \
                                -Dsonar.sources=src/main/java \
                                -Dsonar.tests=src/test/java \
                                -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                                -Dsonar.junit.reportPaths=target/surefire-reports \
                                -Dsonar.exclusions=**/target/**,**/generated-sources/**,**/*Test.java,**/*Tests.java \
                                -Dsonar.test.exclusions=**/target/**,**/generated-sources/** \
                                -Dsonar.maven.scanAll=false \
                                -Dmaven.test.skip=true
                        '''
                    }
                }
            }
        }
        
        // stage('Quality Gate') {
        //     when {
        //         expression { !params.SKIP_SONAR }
        //     }
        //     steps {
        //         timeout(time: 10, unit: 'MINUTES') {
        //             script {
        //                 try {
        //                     def qg = waitForQualityGate()
        //                     if (qg.status != 'OK') {
        //                         echo "Quality gate status: ${qg.status}"
        //                         currentBuild.result = 'UNSTABLE'
        //                         echo "Quality gate failed but continuing pipeline for development environment"
        //                     } else {
        //                         echo "Quality gate passed successfully"
        //                     }
        //                 } catch (Exception e) {
        //                     echo "Quality gate check failed: ${e.getMessage()}"
        //                     currentBuild.result = 'UNSTABLE'
        //                 }
        //             }
        //         }
        //     }
        // }
        
        stage('Build Application') {
            steps {
                dir("${env.SERVICE_NAME}") {
                    sh '''
                        echo "Configurando entorno Java..."
                        
                        # Crear directorio para Java si no existe
                        mkdir -p ${WORKSPACE}/.tools/java
                        
                        # Descargar e instalar OpenJDK si no está instalado
                        if [ ! -d "${WORKSPACE}/.tools/java/openjdk-17" ]; then
                            echo "Instalando OpenJDK 17..."
                            cd ${WORKSPACE}/.tools
                            curl -L https://download.java.net/java/GA/jdk17/0d483333a00540d886896bac774ff48b/35/GPL/openjdk-17_linux-x64_bin.tar.gz -o openjdk.tar.gz
                            tar xzf openjdk.tar.gz
                            mv jdk-17* java/openjdk-17
                            rm openjdk.tar.gz
                        fi
                        
                        # Configurar Java
                        export JAVA_HOME="${WORKSPACE}/.tools/java/openjdk-17"
                        export PATH="$JAVA_HOME/bin:$PATH"
                        
                        echo "Building application ${SERVICE_NAME}..."
                        mvn clean package -DskipTests \
                            -Dspring.profiles.active=dev \
                            -Dmaven.javadoc.skip=true \
                            -Dmaven.compiler.source=17 \
                            -Dmaven.compiler.target=17 \
                            -B -V
                            
                        # Verificar que el JAR se construyó correctamente
                        JAR_FILE=$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -n 1)
                        if [ -z "$JAR_FILE" ]; then
                            echo "ERROR: No se encontró el archivo JAR en target/"
                            ls -la target/
                            exit 1
                        fi
                        
                        echo "JAR construido: $JAR_FILE"
                    '''
                }
            }
        }
        
        stage('🐳 Build Docker Image') {
            steps {
                dir("${env.SERVICE_NAME}") {
                    script {
                        // Verificar permisos de Docker primero
                        sh '''
                            echo "=== Docker Permissions Check ==="
                            echo "Current user: $(whoami)"
                            echo "User ID: $(id)"
                            echo "Docker socket permissions:"
                            ls -l /var/run/docker.sock
                            echo "Docker socket group:"
                            stat -c "%G %g" /var/run/docker.sock
                            echo "Current user groups:"
                            groups
                        '''
                        
                        // Verificar JAR file
                        sh '''
                            echo "=== JAR File Check ==="
                            JAR_FILE=$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -n 1)
                            if [ -z "$JAR_FILE" ]; then
                                echo "ERROR: No se encontró el archivo JAR en target/"
                                ls -la target/
                                exit 1
                            fi
                            echo "JAR encontrado: $JAR_FILE"
                        '''
                        
                        // Crear Dockerfile si no existe
                        sh '''
                            if [ ! -f "Dockerfile" ]; then
                                echo "Creating Dockerfile..."
                                cat > Dockerfile << 'DOCKERFILE_END'
        FROM openjdk:17-jre-slim

        ARG SERVICE_NAME
        ARG VERSION  
        ARG BUILD_DATE
        ARG VCS_REF

        LABEL org.label-schema.build-date=$BUILD_DATE \\
            org.label-schema.name=$SERVICE_NAME \\
            org.label-schema.version=$VERSION \\
            org.label-schema.vcs-ref=$VCS_REF

        WORKDIR /app

        # Copiar el JAR específico
        COPY target/*.jar app.jar

        # Exponer el puerto específico del servicio
        EXPOSE 8080

        # Variables de entorno para Spring Boot
        ENV SPRING_PROFILES_ACTIVE=dev
        ENV JAVA_OPTS="-Xmx512m -Xms256m"

        ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
        DOCKERFILE_END
                                echo "✅ Dockerfile creado"
                            fi
                            
                            echo "Dockerfile content:"
                            cat Dockerfile
                        '''
                        
                        // Intentar construir la imagen
                        sh '''
                            export DOCKER_CLI="${WORKSPACE}/.tools/bin/docker"
                            
                            echo "=== Docker Build Attempt ==="
                            echo "Docker CLI: $DOCKER_CLI"
                            echo "Built Image: ${BUILT_IMAGE}"
                            echo "Built Latest: ${BUILT_LATEST_IMAGE}"
                            echo "Current directory: $(pwd)"
                            echo "Files in directory:"
                            ls -la
                            
                            # Verificar que Docker CLI funciona
                            echo "Testing Docker CLI..."
                            if ! $DOCKER_CLI version; then
                                echo "❌ Docker CLI not working"
                                exit 1
                            fi
                            
                            # Construir la imagen
                            echo "Building Docker image..."
                            BUILD_ARGS="--build-arg SERVICE_NAME=${SERVICE_NAME}"
                            BUILD_ARGS="$BUILD_ARGS --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
                            BUILD_ARGS="$BUILD_ARGS --build-arg VERSION=${IMAGE_TAG}"
                            BUILD_ARGS="$BUILD_ARGS --build-arg VCS_REF=$(git rev-parse HEAD)"
                            
                            echo "Build arguments: $BUILD_ARGS"
                            
                            if $DOCKER_CLI build -t ${BUILT_IMAGE} -t ${BUILT_LATEST_IMAGE} $BUILD_ARGS .; then
                                echo "✅ Docker build successful"
                                
                                # Verificar imágenes construidas
                                echo "=== Verification ==="
                                echo "Images built:"
                                $DOCKER_CLI images | grep ${SERVICE_NAME} || echo "No images found"
                                
                            else
                                echo "❌ Docker build failed"
                                echo "Checking Docker daemon status..."
                                
                                if ! $DOCKER_CLI version >/dev/null 2>&1; then
                                    echo "❌ Docker daemon not accessible"
                                    echo "This is likely a permissions issue."
                                    echo "Solutions:"
                                    echo "1. Add Jenkins user to docker group"
                                    echo "2. Run Jenkins container with docker group access"
                                    echo "3. Use Docker-in-Docker"
                                    exit 1
                                fi
                                
                                echo "Docker daemon is accessible but build failed"
                                echo "Check the build logs above for specific errors"
                                exit 1
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('Security Scan with Trivy') {
            when {
                expression { !params.SKIP_SECURITY_SCAN }
            }
            steps {
                sh '''
                    export PATH=${DOCKER_PATH}:${WORKSPACE}/.tools/bin:$PATH
                    
                    echo "Scanning image ${BUILT_IMAGE}..."
                    trivy image \
                        --format json \
                        --output ${SERVICE_NAME}-trivy-report.json \
                        --severity HIGH,CRITICAL \
                        --no-progress \
                        ${BUILT_IMAGE} || echo "Trivy scan completed with warnings"
                    
                    # Check for vulnerabilities but don't fail the build in dev
                    if [ -f "${SERVICE_NAME}-trivy-report.json" ]; then
                        HIGH_CRITICAL=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length' ${SERVICE_NAME}-trivy-report.json 2>/dev/null || echo "0")
                        echo "Found $HIGH_CRITICAL HIGH/CRITICAL vulnerabilities"
                        
                        if [ "$HIGH_CRITICAL" -gt 10 ]; then
                            echo "WARNING: Too many HIGH/CRITICAL vulnerabilities found ($HIGH_CRITICAL). Consider reviewing before promoting to staging."
                        fi
                    fi
                '''
            }
            post {
                always {
                    script {
                        try {
                            archiveArtifacts artifacts: "${env.SERVICE_NAME}-trivy-report.json", allowEmptyArchive: true
                            echo "Trivy report archived successfully"
                        } catch (Exception e) {
                            echo "Could not archive Trivy report: ${e.getMessage()}"
                        }
                    }
                }
            }
        }
        
        stage('Push to GCP Registry') {
            when {
                expression { !params.SKIP_GCP_PUSH }
            }
            steps {
                sh '''
                    export PATH=${DOCKER_PATH}:${GCLOUD_PATH}:$PATH
                    
                    echo "Configurando autenticación con GCP..."
                    
                    # Verificar que tenemos las credenciales
                    if [ ! -f "$GOOGLE_APPLICATION_CREDENTIALS" ]; then
                        echo "ERROR: No se encontró el archivo de credenciales de GCP"
                        exit 1
                    fi
                    
                    # Autenticar con GCP usando la cuenta de servicio
                    echo "Autenticando con GCP usando cuenta de servicio..."
                    gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS
                    if [ $? -ne 0 ]; then
                        echo "ERROR: Falló la autenticación con GCP"
                        exit 1
                    fi
                    
                    # Configurar el proyecto
                    echo "Configurando proyecto GCP: $GCP_PROJECT_ID"
                    gcloud config set project $GCP_PROJECT_ID
                    if [ $? -ne 0 ]; then
                        echo "ERROR: No se pudo configurar el proyecto GCP"
                        exit 1
                    fi
                    
                    # Configurar Docker para usar GCR
                    echo "Configurando Docker para usar Google Container Registry..."
                    gcloud auth configure-docker gcr.io --quiet
                    if [ $? -ne 0 ]; then
                        echo "ERROR: No se pudo configurar Docker con GCR"
                        exit 1
                    fi
                    
                    # Verificar que la imagen existe localmente
                    if ! docker images | grep -q "${SERVICE_NAME}.*${IMAGE_TAG}"; then
                        echo "ERROR: No se encontró la imagen local ${BUILT_IMAGE}"
                        exit 1
                    fi
                    
                    echo "Pushing images to GCP Registry..."
                    echo "- Pushing ${BUILT_IMAGE}"
                    docker push ${BUILT_IMAGE}
                    if [ $? -ne 0 ]; then
                        echo "ERROR: Falló el push de ${BUILT_IMAGE}"
                        exit 1
                    fi
                    
                    echo "- Pushing ${BUILT_LATEST_IMAGE}"
                    docker push ${BUILT_LATEST_IMAGE}
                    if [ $? -ne 0 ]; then
                        echo "ERROR: Falló el push de ${BUILT_LATEST_IMAGE}"
                        exit 1
                    fi
                    
                    echo "Imágenes publicadas exitosamente en GCP Registry"
                    echo "  - ${BUILT_IMAGE}"
                    echo "  - ${BUILT_LATEST_IMAGE}"
                '''
            }
        }
        
        stage('Deploy to Dev Environment') {
            when {
                expression { !params.SKIP_DEPLOY }
            }
            steps {
                sh '''
                    export PATH=${KUBECTL_PATH}:$PATH
                    
                    echo "Checking Kubernetes deployment..."
                    
                    # Check if kubectl is working
                    kubectl version --client || echo "kubectl not properly configured"
                    
                    # Check if deployment exists
                    if kubectl get deployment ${SERVICE_NAME} -n ecommerce-dev >/dev/null 2>&1; then
                        echo "Updating existing deployment..."
                        kubectl set image deployment/${SERVICE_NAME} \
                            ${SERVICE_NAME}=${BUILT_IMAGE} \
                            -n ecommerce-dev
                        
                        kubectl rollout status deployment/${SERVICE_NAME} \
                            -n ecommerce-dev --timeout=300s
                    else
                        echo "Deployment ${SERVICE_NAME} not found in ecommerce-dev namespace"
                        echo "Skipping deployment step - ensure Kubernetes cluster is configured"
                    fi
                    
                    # Show current status if possible
                    kubectl get pods -n ecommerce-dev -l app=${SERVICE_NAME} 2>/dev/null || echo "Could not check pods"
                    kubectl get services -n ecommerce-dev -l app=${SERVICE_NAME} 2>/dev/null || echo "Could not check services"
                '''
            }
        }
        
        stage('Create PR to Staging') {
            when {
                allOf {
                    equals expected: 'develop', actual: params.BRANCH_NAME
                    expression { env.GITHUB_TOKEN != null }
                }
            }
            steps {
                sh '''
                    echo "PR creation skipped - GitHub token not configured"
                    echo "To enable PR creation:"
                    echo "1. Create GitHub token in Jenkins credentials with ID 'github-token'"
                    echo "2. Uncomment GITHUB_TOKEN in environment section"
                    echo "3. Enable this stage"
                    
                    echo "Manual PR creation info:"
                    echo "Branch: staging-${SERVICE_NAME}-${BUILD_NUMBER}"
                    echo "Image: ${BUILT_IMAGE}"
                    echo "Service: ${SERVICE_NAME}"
                '''
            }
        }
    }
    
    post {
        always {
            script {
                try {
                    sh '''
                        export PATH=${DOCKER_PATH}:$PATH
                        
                        echo "Cleaning up Docker images..."
                        docker rmi ${BUILT_IMAGE} 2>/dev/null || true
                        docker rmi ${BUILT_LATEST_IMAGE} 2>/dev/null || true
                        docker system prune -f 2>/dev/null || true
                    '''
                } catch (Exception e) {
                    echo "Cleanup failed: ${e.getMessage()}"
                }
            }
        }
        
        success {
            script {
                echo "✅ Build Successful - ${env.SERVICE_NAME}"
                echo "🏷️ Version: ${env.IMAGE_TAG}"
                echo "🐳 Image: ${env.BUILT_IMAGE}"
                echo "📊 Build: #${env.BUILD_NUMBER}"
                echo ""
                echo "🔗 Next Steps:"
                echo "- Configure GitHub credentials for PR creation"
                echo "- Set up GCP project access for image pushing"
                echo "- Configure Kubernetes for deployment"
            }
        }
        
        failure {
            script {
                echo "❌ Build Failed - ${env.SERVICE_NAME}"
                echo "🏷️ Version: ${env.IMAGE_TAG}"
                echo "📊 Build: #${env.BUILD_NUMBER}"
                echo "🔗 Pipeline: ${env.BUILD_URL}"
                echo "🔍 Check console output for errors"
            }
        }
        
        unstable {
            script {
                echo "⚠️ Build Unstable - ${env.SERVICE_NAME}"
                echo "🏷️ Version: ${env.IMAGE_TAG}"
                echo "📊 Build: #${env.BUILD_NUMBER}"
                echo "⚠️ Some tests may have failed or quality gates have warnings"
            }
        }
    }
}

// Helper Functions
def getServicePort(serviceName) {
    def servicePorts = [
        'order-service': '8300',
        'payment-service': '8400',
        'product-service': '8500',
        'shipping-service': '8600',
        'user-service': '8700',
        'api-gateway': '8080',
        'service-discovery': '8761',
        'cloud-config': '8888'
    ]
    return servicePorts[serviceName] ?: '8080'
}