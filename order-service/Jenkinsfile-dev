pipeline {
    agent any
    
    parameters {
        string(name: 'BRANCH_NAME', defaultValue: 'develop', description: 'Branch to build')
        string(name: 'COMMIT_SHA', defaultValue: 'HEAD', description: 'Commit SHA')
        booleanParam(name: 'SKIP_SONAR', defaultValue: false, description: 'Skip SonarQube analysis')
        booleanParam(name: 'SKIP_SECURITY_SCAN', defaultValue: false, description: 'Skip Trivy security scan')
    }
    
    environment {
        // GCP Configuration
        GCP_PROJECT_ID = 'ecommerce-microservices-back'
        GCP_REGISTRY = "gcr.io/${GCP_PROJECT_ID}"
        
        // Service name will be set dynamically in the Initialize stage
        SERVICE_NAME = ''
        
        // Versioning
        IMAGE_TAG = "${params.COMMIT_SHA.take(7)}-${BUILD_NUMBER}"
        
        // Service configuration (will be set dynamically)
        SERVICE_PORT = ''
        
        // Credentials
        GOOGLE_APPLICATION_CREDENTIALS = credentials('gcp-service-account-key')
        SONAR_TOKEN = credentials('sonarqube-token')
        GITHUB_TOKEN = credentials('github-token')
        SLACK_WEBHOOK = credentials('slack-webhook-url')
    }
    
    tools {
        maven 'Maven-3.9.4'
        jdk 'OpenJDK-17'
    }
    
    stages {
        stage('üèÅ Initialize') {
            steps {
                script {
                    // Set dynamic environment variables
                    env.SERVICE_NAME = env.JOB_NAME.split('-dev')[0]
                    env.SERVICE_PORT = getServicePort(env.SERVICE_NAME)
                    
                    currentBuild.description = "Building ${env.SERVICE_NAME}:${env.IMAGE_TAG}"
                    
                    echo "=== Pipeline Configuration ==="
                    echo "Service: ${env.SERVICE_NAME}"
                    echo "Port: ${env.SERVICE_PORT}"
                    echo "Image Tag: ${env.IMAGE_TAG}"
                    echo "Branch: ${params.BRANCH_NAME}"
                    echo "GCP Registry: ${env.GCP_REGISTRY}"
                    
                    // Initialize GCP
                    sh '''
                        export GOOGLE_APPLICATION_CREDENTIALS=$GOOGLE_APPLICATION_CREDENTIALS
                        gcloud auth activate-service-account --key-file=$GOOGLE_APPLICATION_CREDENTIALS
                        gcloud config set project $GCP_PROJECT_ID
                        gcloud auth configure-docker gcr.io --quiet
                    '''
                }
            }
        }
        
        stage('üì• Checkout & Change Detection') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "${params.BRANCH_NAME}"]],
                    userRemoteConfigs: [[
                        url: 'https://github.com/ecommerce-devops-lab/ecommerce-microservice-backend-app.git',
                        credentialsId: 'github-credentials'
                    ]]
                ])
                
                script {
                    // Detect changes for this specific service
                    def hasChanges = sh(
                        script: """
                            if [ "${params.BRANCH_NAME}" = "develop" ] && [ "${params.COMMIT_SHA}" != "HEAD" ]; then
                                git diff --name-only ${params.COMMIT_SHA}~1 ${params.COMMIT_SHA} | grep -q "^${env.SERVICE_NAME}/" || echo "no-changes"
                            else
                                echo "force-build"
                            fi
                        """,
                        returnStdout: true
                    ).trim()
                    
                    if (hasChanges == 'no-changes') {
                        currentBuild.result = 'NOT_BUILT'
                        currentBuild.description = "No changes detected for ${env.SERVICE_NAME}"
                        echo "No changes detected for ${env.SERVICE_NAME}, but continuing build as requested"
                    }
                }
            }
        }
        
        stage('üß™ Unit Tests') {
            steps {
                dir("${env.SERVICE_NAME}") {
                    sh '''
                        echo "Running unit tests for ${SERVICE_NAME}..."
                        mvn clean test \
                            -Dmaven.test.failure.ignore=false \
                            -Dspring.profiles.active=test \
                            -DforkCount=2 \
                            -DreuseForks=true
                    '''
                }
            }
            post {
                always {
                    publishTestResults(
                        testResultsPattern: "${env.SERVICE_NAME}/target/surefire-reports/*.xml",
                        allowEmptyResults: false
                    )
                    publishCoverage([
                        adapters: [jacocoAdapter("${env.SERVICE_NAME}/target/site/jacoco/jacoco.xml")],
                        sourceFileResolver: sourceFiles('STORE_LAST_BUILD')
                    ])
                }
            }
        }
        
        stage('üìä SonarQube Analysis') {
            when {
                expression { !params.SKIP_SONAR }
            }
            steps {
                dir("${env.SERVICE_NAME}") {
                    withSonarQubeEnv('sonarqube-server') {
                        sh '''
                            mvn sonar:sonar \
                                -Dsonar.projectKey=ecommerce-${SERVICE_NAME}-dev \
                                -Dsonar.projectName="E-commerce ${SERVICE_NAME} (DEV)" \
                                -Dsonar.branch.name=${BRANCH_NAME} \
                                -Dsonar.coverage.jacoco.xmlReportPaths=target/site/jacoco/jacoco.xml \
                                -Dsonar.java.source=17 \
                                -Dsonar.exclusions=**/target/**,**/generated-sources/**
                        '''
                    }
                }
            }
        }
        
        stage('üö™ Quality Gate') {
            when {
                expression { !params.SKIP_SONAR }
            }
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    script {
                        def qg = waitForQualityGate()
                        if (qg.status != 'OK') {
                            error "Pipeline aborted due to quality gate failure: ${qg.status}"
                        }
                    }
                }
            }
        }
        
        stage('üì¶ Build Application') {
            steps {
                dir("${env.SERVICE_NAME}") {
                    sh '''
                        echo "Building application ${SERVICE_NAME}..."
                        mvn package -DskipTests \
                            -Dspring.profiles.active=dev \
                            -Dmaven.javadoc.skip=true \
                            -B -V
                    '''
                }
            }
        }
        
        stage('üê≥ Build Docker Image') {
            steps {
                dir("${env.SERVICE_NAME}") {
                    script {
                        def gcpImage = "${env.GCP_REGISTRY}/${env.SERVICE_NAME}:${env.IMAGE_TAG}"
                        def gcpLatestImage = "${env.GCP_REGISTRY}/${env.SERVICE_NAME}:dev-latest"
                        
                        sh """
                            echo "Building Docker image..."
                            docker build \
                                -t ${gcpImage} \
                                -t ${gcpLatestImage} \
                                --build-arg SERVICE_NAME=${env.SERVICE_NAME} \
                                --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                --build-arg VERSION=${env.IMAGE_TAG} \
                                --build-arg VCS_REF=\$(git rev-parse HEAD) \
                                .
                            
                            echo "Images built:"
                            docker images | grep ${env.SERVICE_NAME}
                        """
                        
                        env.BUILT_IMAGE = gcpImage
                        env.BUILT_LATEST_IMAGE = gcpLatestImage
                    }
                }
            }
        }
        
        stage('üîí Security Scan with Trivy') {
            when {
                expression { !params.SKIP_SECURITY_SCAN }
            }
            steps {
                script {
                    sh """
                        echo "Installing Trivy..."
                        if ! command -v trivy &> /dev/null; then
                            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin v0.48.3
                        fi
                        
                        echo "Scanning image ${env.BUILT_IMAGE}..."
                        trivy image \
                            --format json \
                            --output ${env.SERVICE_NAME}-trivy-report.json \
                            --severity HIGH,CRITICAL \
                            --no-progress \
                            ${env.BUILT_IMAGE}
                        
                        HIGH_CRITICAL=\$(trivy image --format json --quiet ${env.BUILT_IMAGE} | jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL")] | length')
                        
                        echo "Found \$HIGH_CRITICAL HIGH/CRITICAL vulnerabilities"
                        
                        if [ "\$HIGH_CRITICAL" -gt 10 ]; then
                            echo "WARNING: Too many HIGH/CRITICAL vulnerabilities found (\$HIGH_CRITICAL). Consider reviewing before promoting to staging."
                        fi
                    """
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: "${env.SERVICE_NAME}-trivy-report.json", allowEmptyArchive: true
                }
            }
        }
        
        stage('üì§ Push to GCP Registry') {
            steps {
                script {
                    sh """
                        echo "Pushing images to GCP Registry..."
                        docker push ${env.BUILT_IMAGE}
                        docker push ${env.BUILT_LATEST_IMAGE}
                        
                        echo "Images pushed successfully:"
                        echo "- ${env.BUILT_IMAGE}"
                        echo "- ${env.BUILT_LATEST_IMAGE}"
                    """
                }
            }
        }
        
        stage('üöÄ Deploy to Dev Environment') {
            steps {
                script {
                    sh """
                        echo "Deploying ${env.SERVICE_NAME} to development environment..."
                        kubectl set image deployment/${env.SERVICE_NAME} \
                            ${env.SERVICE_NAME}=${env.BUILT_IMAGE} \
                            -n ecommerce-dev
                        
                        kubectl rollout status deployment/${env.SERVICE_NAME} \
                            -n ecommerce-dev --timeout=300s
                        
                        kubectl get pods -n ecommerce-dev -l app=${env.SERVICE_NAME}
                        kubectl get services -n ecommerce-dev -l app=${env.SERVICE_NAME}
                    """
                }
            }
        }
        
        stage('üß™ Health Check Verification') {
            steps {
                script {
                    sh """
                        echo "Performing health check for ${env.SERVICE_NAME}..."
                        SERVICE_IP=\$(kubectl get service ${env.SERVICE_NAME} -n ecommerce-dev -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || kubectl get service ${env.SERVICE_NAME} -n ecommerce-dev -o jsonpath='{.spec.clusterIP}')
                        
                        if [ -z "\$SERVICE_IP" ]; then
                            echo "Could not get service IP, checking pod directly..."
                            POD_NAME=\$(kubectl get pods -n ecommerce-dev -l app=${env.SERVICE_NAME} -o jsonpath='{.items[0].metadata.name}')
                            kubectl port-forward -n ecommerce-dev \$POD_NAME ${env.SERVICE_PORT}:${env.SERVICE_PORT} &
                            PF_PID=\$!
                            sleep 5
                            SERVICE_IP="localhost"
                        fi
                        
                        max_attempts=30
                        attempt=1
                        
                        while [ \$attempt -le \$max_attempts ]; do
                            echo "Health check attempt \$attempt/\$max_attempts..."
                            if curl -f -s http://\$SERVICE_IP:${env.SERVICE_PORT}/actuator/health; then
                                echo ""
                                echo "‚úÖ Health check passed for ${env.SERVICE_NAME}"
                                break
                            fi
                            sleep 10
                            attempt=\$((attempt + 1))
                        done
                        
                        if [ ! -z "\$PF_PID" ]; then
                            kill \$PF_PID 2>/dev/null || true
                        fi
                        
                        if [ \$attempt -gt \$max_attempts ]; then
                            echo "‚ùå Health check failed after \$max_attempts attempts"
                            exit 1
                        fi
                    """
                }
            }
        }
        
        stage('üìù Create PR to Staging') {
            when {
                equals expected: 'develop', actual: params.BRANCH_NAME
            }
            steps {
                script {
                    sh """
                        echo "Creating PR to staging branch..."
                        git config user.name "Jenkins CI"
                        git config user.email "jenkins@tu-dominio.com"
                        
                        git checkout -B staging-${env.SERVICE_NAME}-${env.BUILD_NUMBER}
                        git push origin staging-${env.SERVICE_NAME}-${env.BUILD_NUMBER}
                        
                        REPO_NAME=\$(echo 'https://github.com/ecommerce-devops-lab/ecommerce-microservice-backend-app.git' | sed 's|https://github.com/||' | sed 's|\\.git||')
                        
                        curl -X POST \
                            -H "Authorization: token ${env.GITHUB_TOKEN}" \
                            -H "Accept: application/vnd.github.v3+json" \
                            -H "Content-Type: application/json" \
                            https://api.github.com/repos/\$REPO_NAME/pulls \
                            -d '{
                                "title": "üöÄ Auto-promotion: '${env.SERVICE_NAME}' '${env.IMAGE_TAG}' to staging",
                                "head": "staging-'${env.SERVICE_NAME}'-'${env.BUILD_NUMBER}'",
                                "base": "staging",
                                "body": "## Automatic Promotion to Staging\\n\\n**Service:** '${env.SERVICE_NAME}'\\n**Version:** '${env.IMAGE_TAG}'\\n**Build:** '${env.BUILD_NUMBER}'\\n\\n### ‚úÖ Validations Completed\\n- Unit Tests: Passed\\n- Code Quality: SonarQube passed\\n- Security Scan: Trivy completed\\n- Docker Image: Built and pushed to GCR\\n- Deployment: Successfully deployed to dev\\n- Health Check: Verified\\n\\n### üì¶ Artifacts\\n- **Image:** '${env.BUILT_IMAGE}'\\n- **Latest:** '${env.BUILT_LATEST_IMAGE}'\\n\\n### üîó Links\\n- [Jenkins Build]('${env.BUILD_URL}')\\n- [Test Results]('${env.BUILD_URL}'testReport/)\\n- [SonarQube Report](https://sonarqube.tu-dominio.com/dashboard?id=ecommerce-'${env.SERVICE_NAME}'-dev)\\n\\n**Ready for staging deployment! üöÄ**"
                            }' || echo "PR creation completed (may already exist)"
                    """
                }
            }
        }
    }
    
    post {
        always {
            script {
                sh """
                    echo "Cleaning up Docker images..."
                    docker rmi ${env.BUILT_IMAGE} || true
                    docker rmi ${env.BUILT_LATEST_IMAGE} || true
                    docker system prune -f || true
                """
            }
        }
        
        success {
            script {
                def message = """‚úÖ *Build Successful* - ${env.SERVICE_NAME}
                    
üè∑Ô∏è **Version:** ${env.IMAGE_TAG}
üê≥ **Image:** ${env.BUILT_IMAGE}
üöÄ **Deployed to:** Development Environment
üìä **Build:** #${env.BUILD_NUMBER}
üîó **Pipeline:** ${env.BUILD_URL}

‚úÖ **Next Steps:**
‚Ä¢ PR created to staging branch
‚Ä¢ Ready for staging deployment
‚Ä¢ Health checks passed"""

                sendSlackNotification('good', message)
            }
        }
        
        failure {
            script {
                def message = """‚ùå *Build Failed* - ${env.SERVICE_NAME}
                    
üè∑Ô∏è **Version:** ${env.IMAGE_TAG}
üìä **Build:** #${env.BUILD_NUMBER}
üîó **Pipeline:** ${env.BUILD_URL}
‚è∞ **Duration:** ${currentBuild.durationString}

üîç **Action Required:**
‚Ä¢ Check console output for errors
‚Ä¢ Review failed stage logs
‚Ä¢ Fix issues and retry build"""

                sendSlackNotification('danger', message)
            }
        }
        
        unstable {
            script {
                def message = """‚ö†Ô∏è *Build Unstable* - ${env.SERVICE_NAME}
                    
üè∑Ô∏è **Version:** ${env.IMAGE_TAG}
üìä **Build:** #${env.BUILD_NUMBER}
üîó **Pipeline:** ${env.BUILD_URL}

‚ö†Ô∏è **Issues Found:**
‚Ä¢ Some tests may have failed
‚Ä¢ Quality gates may have warnings
‚Ä¢ Review test results before promoting"""

                sendSlackNotification('warning', message)
            }
        }
    }
}

// Helper Functions
def getServicePort(serviceName) {
    def servicePorts = [
        'order-service': '8300',
        'payment-service': '8400',
        'product-service': '8500',
        'shipping-service': '8600',
        'user-service': '8700',
        'api-gateway': '8080',
        'service-discovery': '8761',
        'cloud-config': '8888'
    ]
    return servicePorts[serviceName] ?: '8080'
}

def sendSlackNotification(String color, String message) {
    if (env.SLACK_WEBHOOK) {
        try {
            sh """
                curl -X POST -H 'Content-type: application/json' \
                    --data '{
                        "attachments": [{
                            "color": "${color}",
                            "text": "${message}",
                            "footer": "Jenkins CI/CD Pipeline",
                            "ts": ${System.currentTimeMillis() / 1000}
                        }]
                    }' \
                    ${env.SLACK_WEBHOOK}
            """
        } catch (Exception e) {
            echo "Failed to send Slack notification: ${e.getMessage()}"
        }
    }
}